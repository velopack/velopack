// Automatically generated by flapigen
#pragma once

//for (u)intX_t types
#include <stdint.h>

#ifdef __cplusplus
static_assert(sizeof(uintptr_t) == sizeof(uint8_t) * 8,
   "our conversion usize <-> uintptr_t is wrong");
#endif
            #include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif
struct CRustStrView {
    const char * data;
    uintptr_t len;
};

#ifdef __cplusplus
} // extern "C" {
#endif
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif
struct CRustString {
    const char * data;
    uintptr_t len;
    uintptr_t capacity;
};

#ifdef __cplusplus
} // extern "C" {
#endif

#ifdef __cplusplus
extern "C" {
#endif
void crust_string_free(struct CRustString x);
#ifdef __cplusplus
} // extern "C" {
#endif

#ifdef __cplusplus
extern "C" {
#endif
struct CRustString crust_string_clone(struct CRustString x);
#ifdef __cplusplus
} // extern "C" {
#endif

#ifdef __cplusplus

#include <string>

#include <string_view>

namespace velopack_cpp {
class RustString final : private CRustString {
public:
    explicit RustString(const CRustString &o) noexcept
    {
        data = o.data;
        len = o.len;
        capacity = o.capacity;
    }
    RustString() noexcept { reset(*this); }
    RustString(const RustString &o) noexcept
        : RustString(crust_string_clone(o))
    {
    }
    RustString &operator=(const RustString &o) noexcept
    {
        if (this != &o) {
            free_mem();
            auto copy = crust_string_clone(o);
            data = copy.data;
            len = copy.len;
            capacity = copy.capacity;
        }
        return *this;
    }
    RustString(RustString &&o) noexcept
    {
        data = o.data;
        len = o.len;
        capacity = o.capacity;

        reset(o);
    }
    RustString &operator=(RustString &&o) noexcept
    {
        free_mem();
        data = o.data;
        len = o.len;
        capacity = o.capacity;

        reset(o);
        return *this;
    }
    ~RustString() noexcept { free_mem(); }
    std::string to_std_string() const { return std::string(data, len); }
    size_t size() const noexcept { return this->len; }
    bool empty() const noexcept { return this->len == 0; }

    std::string_view to_string_view() const { return std::string_view(data, len); }

private:
    void free_mem() noexcept
    {
        if (data != nullptr) {
            crust_string_free(*this);
            reset(*this);
        }
    }
    static void reset(RustString &o) noexcept
    {
        o.data = nullptr;
        o.len = 0;
        o.capacity = 0;
    }
};
} // namespace velopack_cpp
#endif // __cplusplus
