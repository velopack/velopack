// Package velopack provides a Go interface to the Velopack library for managing software updates.
package velopack

/*
#include <stdlib.h>
#include "../../lib-cpp/include/Velopack.h"
*/
import "C"
import (
	"errors"
	"runtime"
	"unsafe"
)

var (
	AutoApplyOnStartup bool           = true // sets whether to automatically apply downloaded updates on startup.
	Args               []string              // Overrides the command line arguments used by VelopackApp.
	Locator            *LocatorConfig        // Sets the locator configuration to use for the VelopackApp.

	HookFirstRun  func(psz_app_version string) // This hook is triggered when the application is started for the first time after installation.
	HookRestarted func(psz_app_version string) // This hook is triggered when the application is restarted by Velopack after installing updates.

	// WARNING: Windows hooks are run during critical stages of Velopack operations.
	// Your code will be run and then the process will exit.
	// If your code has not completed within 30 seconds, it will be terminated.
	// Only supported on windows; On other operating systems, these callbacks will never be called.
	WindowsHookAfterInstall    func(psz_app_version string)
	WindowsHookBeforeUninstall func(psz_app_version string)
	WindowsHookBeforeUpdate    func(psz_app_version string)
	WindowsHookAfterUpdate     func(psz_app_version string)

	Logger func(psz_level, psz_message string) // Will be called for all log messages generated by the Velopack library.
)

// UpdateCheck represents the result of a call to check for updates. This can indicate that an update is available, or that an error occurred.
type UpdateCheck C.vpkc_update_check_t

const (
	UpdateError       UpdateCheck = -1
	UpdateAvailable   UpdateCheck = 0
	NoUpdateAvailable UpdateCheck = 1
	RemoteIsEmpty     UpdateCheck = 2
)

// AssetType (eg. "Full" or "Delta").
type AssetType string

const (
	AssetTypeFull  AssetType = "Full"
	AssetTypeDelta AssetType = "Delta"
)

// Asset is an individual Velopack asset, could refer to an asset on-disk or in a remote package feed.
type Asset struct {
	assetAndOrSilentAndOrRestart

	handle unsafe.Pointer // opaque handle to the underlying C asset, if applicable.

	PackageID     string    // The name or ID of the package containing this release.
	Version       string    // The version of this release.
	Type          AssetType // The type of asset (eg. "Full" or "Delta").
	Filename      string    // The filename of the update package containing this release.
	SHA1          string    // The SHA1 checksum of the update package containing this release.
	SHA256        string    // The SHA256 checksum of the update package containing this release.
	Size          uint64    // The size in bytes of the update package containing this release.
	NotesMarkdown string    // The release notes in markdown format, as passed to Velopack when packaging the release. This may be an empty string.
	NotesHTML     string    // The release notes in HTML format, transformed from Markdown when packaging the release. This may be an empty string.
}

func toAsset(asset *C.vpkc_asset_t) *Asset {
	if asset == nil {
		return nil
	}
	converted := &Asset{
		handle:        unsafe.Pointer(asset),
		PackageID:     C.GoString(asset.PackageId),
		Version:       C.GoString(asset.Version),
		Type:          AssetType(C.GoString(asset.Type)),
		Filename:      C.GoString(asset.FileName),
		SHA1:          C.GoString(asset.SHA1),
		SHA256:        C.GoString(asset.SHA256),
		Size:          uint64(asset.Size),
		NotesMarkdown: C.GoString(asset.NotesMarkdown),
		NotesHTML:     C.GoString(asset.NotesHtml),
	}
	runtime.AddCleanup(converted, func(handle unsafe.Pointer) {
		C.vpkc_free_asset((*C.vpkc_asset_t)(handle))
	}, converted.handle)
	return converted
}

// UpdateOptions to customise the behaviour of UpdateManager.
type UpdateOptions struct {
	updateOptionsAndLocatorConfig

	/*
		Allows UpdateManager to update to a version that's lower than the current version (i.e. downgrading).
		This could happen if a release has bugs and was retracted from the release feed, or if you're using
		ExplicitChannel to switch channels to another channel where the latest version on that
		channel is lower than the current version.
	*/
	AllowVersionDowngrade bool
	/*
		This option should usually be left None/NULL**.
		Overrides the default channel used to fetch updates.
		The default channel will be whatever channel was specified on the command line when building this release.
		For example, if the current release was packaged with '--channel beta', then the default channel will be 'beta'.
		This allows users to automatically receive updates from the same channel they installed from. This options
		allows you to explicitly switch channels, for example if the user wished to switch back to the 'stable' channel
		without having to reinstall the application.
	*/
	ExplicitChannel string
	/*
		Sets the maximum number of deltas to consider before falling back to a full update.
		The default is 10. Set to a negative number (eg. -1) to disable deltas.
	*/
	MaximumDeltasBeforeFallback int32
}

// UpdateInfo holds information about the current version and pending updates, such as how many there are, and access to release notes.
type UpdateInfo struct {
	handle *C.vpkc_update_info_t // opaque handle to the underlying C update info, if applicable.

	TargetFullRelease *Asset   // The available version that we are updating to.
	BaseRelease       *Asset   // The base release that this update is based on. This is only available if the update is a delta update.
	DeltasToTarget    []*Asset // The list of delta updates that can be applied to the base version to get to the target version.
	/*
		True if the update is a version downgrade or lateral move (such as when switching channels to the same version number).
		In this case, only full updates are allowed, and any local packages on disk newer than the downloaded version will be
		deleted.
	*/
	IsDowngrade bool
}

// LocatorConfig for locating the current app important paths (eg. path to packages, update binary, and so forth).
type LocatorConfig struct {
	updateOptionsAndLocatorConfig

	RootAppDir       string // The root directory of the current app.
	UpdateExePath    string // The path to the Update.exe binary.
	PackagesDir      string // The path to the packages' directory.
	ManifestPath     string // The current app manifest.
	CurrentBinaryDir string // The directory containing the application's user binaries.
	IsPortable       bool   //  Whether the current application is portable or installed.
}

// ProgressCallbackID identifies a progress callback for download operations.
type ProgressCallbackID C.size_t

// UpdateSource is an opaque handle, to either a FileSource, HTTPSource or _CUSTOM_.
type UpdateSource struct {
	handle unsafe.Pointer
}

func get_last_error() error {
	var buf [512]byte
	n := C.vpkc_get_last_error((*C.char)(unsafe.Pointer(&buf[0])), C.size_t(len(buf)))
	return errors.New(string(buf[:min(n, C.size_t(len(buf)))]))
}

// NewSourceFile creates a new FileSource update source for the given local directory path containing updates.
func NewSourceFile(psz_file_path string) (*UpdateSource, error) {
	file_path := C.CString(psz_file_path)
	defer C.free(unsafe.Pointer(file_path))
	source := new(UpdateSource)
	source.handle = C.vpkc_new_source_file(file_path)
	if source.handle == nil {
		return nil, get_last_error()
	}
	runtime.AddCleanup(source, func(handle unsafe.Pointer) {
		C.vpkc_free_source(handle)
	}, source.handle)
	return source, nil
}

// NewSourceHTTP creates a new HttpSource update source for the given HTTP URL of a remote update server.
func NewSourceHTTP(psz_http_url string) (*UpdateSource, error) {
	http_url := C.CString(psz_http_url)
	defer C.free(unsafe.Pointer(http_url))
	source := new(UpdateSource)
	source.handle = C.vpkc_new_source_http_url(http_url)
	if source.handle == nil {
		return nil, get_last_error()
	}
	runtime.AddCleanup(source, func(handle unsafe.Pointer) {
		C.vpkc_free_source(handle)
	}, source.handle)
	return source, nil
}

type updateOptionsAndLocatorConfig interface {
	isUpdateOptionsAndLocatorConfig()
}

func optionsLocator(options ...updateOptionsAndLocatorConfig) (*C.vpkc_update_options_t, *C.vpkc_locator_config_t) {
	var p_options *C.vpkc_update_options_t
	var p_locator *C.vpkc_locator_config_t
	if len(options) > 0 {
		for _, option := range options {
			switch option := option.(type) {
			case *UpdateOptions:
				ExplicitChannel := C.CString(option.ExplicitChannel)
				defer C.free(unsafe.Pointer(ExplicitChannel))
				p_options = &C.vpkc_update_options_t{
					AllowVersionDowngrade:       C.bool(option.AllowVersionDowngrade),
					ExplicitChannel:             ExplicitChannel,
					MaximumDeltasBeforeFallback: C.int32_t(option.MaximumDeltasBeforeFallback),
				}
			case *LocatorConfig:
				RootAppDir := C.CString(option.RootAppDir)
				defer C.free(unsafe.Pointer(RootAppDir))
				UpdateExePath := C.CString(option.UpdateExePath)
				defer C.free(unsafe.Pointer(UpdateExePath))
				PackagesDir := C.CString(option.PackagesDir)
				defer C.free(unsafe.Pointer(PackagesDir))
				ManifestPath := C.CString(option.ManifestPath)
				defer C.free(unsafe.Pointer(ManifestPath))
				CurrentBinaryDir := C.CString(option.CurrentBinaryDir)
				defer C.free(unsafe.Pointer(CurrentBinaryDir))
				p_locator = &C.vpkc_locator_config_t{
					RootAppDir:       RootAppDir,
					UpdateExePath:    UpdateExePath,
					PackagesDir:      PackagesDir,
					ManifestPath:     ManifestPath,
					CurrentBinaryDir: CurrentBinaryDir,
					IsPortable:       C.bool(option.IsPortable),
				}
			}
		}
	}
	return p_options, p_locator
}

// UpdateManager is an opaque handle.
type UpdateManager struct {
	handle           unsafe.Pointer
	custom_callbacks []SourceCustomCallbacks // simple keep alive so that callbacks are not garbage collected whilst the UpdateManager is reachable.
}

// NewUpdateManager creates a new UpdateManager instance from the given update location with optional [UpdateOptions] and [LocatorConfig].
func NewUpdateManager(psz_url_or_path string, options ...updateOptionsAndLocatorConfig) (*UpdateManager, error) {
	p_options, p_locator := optionsLocator(options...)
	url_or_path := C.CString(psz_url_or_path)
	defer C.free(unsafe.Pointer(url_or_path))
	manager := new(UpdateManager)
	if !C.vpkc_new_update_manager(url_or_path, p_options, p_locator, &manager.handle) {
		return nil, get_last_error()
	}
	runtime.AddCleanup(manager, func(handle unsafe.Pointer) {
		C.vpkc_free_update_manager(handle)
	}, manager.handle)
	return manager, nil
}

// NewUpdateManagerFromSource creates a new UpdateManager instance using the given UpdateSource.
func NewUpdateManagerFromSource(source *UpdateSource, options ...updateOptionsAndLocatorConfig) (*UpdateManager, error) {
	p_options, p_locator := optionsLocator(options...)
	manager := new(UpdateManager)
	if !C.vpkc_new_update_manager_with_source(source.handle, p_options, p_locator, &manager.handle) {
		return nil, get_last_error()
	}
	runtime.AddCleanup(manager, func(handle unsafe.Pointer) {
		C.vpkc_free_update_manager(handle)
	}, manager.handle)
	return manager, nil
}

// CurrentVersion returns the currently installed version of the app.
func (up *UpdateManager) CurrentVersion() string {
	var len = C.vpkc_get_current_version(up.handle, nil, 0)
	var buf = make([]byte, len+1) // +1 for null terminator
	C.vpkc_get_current_version(up.handle, (*C.char)(unsafe.Pointer(&buf[0])), C.size_t(len))
	return string(buf[:len]) // return the string without the null terminator
}

// AppID returns the currently installed app id.
func (up *UpdateManager) AppID() string {
	var len = C.vpkc_get_app_id(up.handle, nil, 0)
	var buf = make([]byte, len+1) // +1 for null terminator
	C.vpkc_get_app_id(up.handle, (*C.char)(unsafe.Pointer(&buf[0])), C.size_t(len))
	return string(buf[:len]) // return the string without the null terminator
}

// IsPortable returns whether the app is in portable mode. On Windows this can be true or false.
// On MacOS and Linux this will always be true.
func (up *UpdateManager) IsPortable() bool {
	return bool(C.vpkc_is_portable(up.handle))
}

// UpdatePendingRestart returns an asset if there is an update downloaded which still needs to be
// applied. You can pass this asset to [UpdateManager.WaitExitThenApplyUpdates] to apply the update.
func (up *UpdateManager) UpdatePendingRestart() (*Asset, bool) {
	var asset *C.vpkc_asset_t
	if !C.vpkc_update_pending_restart(up.handle, &asset) {
		return nil, false
	}
	return toAsset(asset), true
}

// CheckForUpdates Checks for updates. If there are updates available, this method will return an [UpdateInfo]
// object containing the latest available release, and any delta updates that can be applied if they are available.
func (up *UpdateManager) CheckForUpdates() (*UpdateInfo, UpdateCheck) {
	var update_info *C.vpkc_update_info_t
	check_result := C.vpkc_check_for_updates(up.handle, &update_info)
	if update_info == nil {
		return nil, UpdateCheck(check_result)
	}
	var deltas []*Asset
	if update_info.DeltasToTarget != nil {
		for ptr := update_info.DeltasToTarget; *ptr != nil; ptr = (**C.vpkc_asset_t)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + unsafe.Sizeof(*ptr))) {
			deltas = append(deltas, toAsset(*ptr))
		}
	}
	info := &UpdateInfo{
		handle:            update_info,
		TargetFullRelease: toAsset(update_info.TargetFullRelease),
		BaseRelease:       toAsset(update_info.BaseRelease),
		DeltasToTarget:    deltas,
		IsDowngrade:       bool(update_info.IsDowngrade),
	}
	runtime.AddCleanup(info, func(handle *C.vpkc_update_info_t) {
		C.vpkc_free_update_info(handle)
	}, info.handle)
	return info, UpdateCheck(check_result)
}

type assetAndOrSilentAndOrRestart interface {
	isAssetAndOrSilentAndOrRestart()
}

// Silent can be passed to [UpdateManager.WaitExitThenApplyUpdates] to attempt to apply the update without showing any UI.
type Silent bool

func (Silent) isAssetAndOrSilentAndOrRestart() {}

// Restart command line arguments to pass to the new process when it's restarted (can be passed to [UpdateManager.WaitExitThenApplyUpdates]).
type Restart []string

func (Restart) isAssetAndOrSilentAndOrRestart() {}

func assetSilentRestart(options ...assetAndOrSilentAndOrRestart) (*C.vpkc_asset_t, C.bool, int, **C.char) {
	var p_asset *C.vpkc_asset_t
	var silent C.bool
	var restart []*C.char
	for _, option := range options {
		switch option := option.(type) {
		case Asset:
			p_asset = (*C.vpkc_asset_t)(unsafe.Pointer(option.handle))
		case Silent:
			silent = C.bool(option)
		case Restart:
			restart = make([]*C.char, len(option)+1) // +1 for null terminator
			for i, arg := range option {
				arg_cstr := C.CString(arg)
				defer C.free(unsafe.Pointer(arg_cstr))
				restart[i] = arg_cstr
			}
		}
	}
	var restartPtr **C.char
	if len(restart) > 0 {
		restartPtr = (**C.char)(unsafe.Pointer(&restart[0]))
	}
	return p_asset, silent, len(restart), restartPtr
}

// WaitExitThenApplyUpdates this will launch the Velopack updater and tell it to wait for this program
// to exit gracefully.
//   - You should then clean up any state and exit your app. The updater will apply updates and then
//   - (if specified) restart your app. The updater will only wait for 60 seconds before giving up.
func (up *UpdateManager) WaitExitThenApplyUpdates(options ...assetAndOrSilentAndOrRestart) error {
	p_asset, silent, restart, restartPtr := assetSilentRestart(options...)
	if !C.vpkc_wait_exit_then_apply_updates(up.handle, p_asset, silent, restart != 0, restartPtr, C.size_t(restart-1)) {
		return get_last_error()
	}
	return nil
}

/*
UnsafeApplyUpdates will launch the Velopack updater and optionally wait for a program to exit gracefully.
This method is unsafe because it does not necessarily wait for any / the correct process to exit
before applying updates. The `vpkc_wait_exit_then_apply_updates` method is recommended for most use cases.
If dw_wait_pid is 0, the updater will not wait for any process to exit before applying updates (Not Recommended).
*/
func (up *UpdateManager) UnsafeApplyUpdates(dw_wait_pid uint32, options ...assetAndOrSilentAndOrRestart) {
	p_asset, silent, restart, restartPtr := assetSilentRestart(options...)
	C.vpkc_unsafe_apply_updates(up.handle, p_asset, silent, C.uint32_t(dw_wait_pid), restart != 0, restartPtr, C.size_t(restart-1))
	if err := get_last_error(); err != nil {
		panic(err)
	}
}
